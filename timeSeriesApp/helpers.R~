# Note: time_series is designed to work with the data set from chronos server (http://www.dpi.inpe.br/tws/wtss). It may not 
# work correctly with other data sets if their schema does not exactly match the schema with which this function is according

library(devtools)
library(wtss.R)
library(zoo)
library(lubridate)
library(bfast)
library(dtwSat)

AMOUNT_OF_SELECTED_ATTRIBUTES = 6 #TROCAR ISSO QUANDO O PLOT DO TWDTW ESTIVER FUNCIONANDO PARA QUALQUER QUANTIDADE DE ATRIBUTOS!!!

# Get time series attributes
get_attributes <- function(time_series)
{  time_series[[names(time_series)]]$attributes  }

# Apply BFAST 01
apply_bfast01 <- function(time_series)
{   # Time series in a ts object with all the original values
   ts_whole = ts(coredata(time_series[,1]), freq=365.25/(as.numeric(difftime(index(time_series[2]), index(time_series[1]), units="days"))), start=decimal_date(ymd(index(time_series[1]))))
   
   # Using BFAST for checking for one major break in the time series
   bfast01(ts_whole)
}

# Apply BFAST
apply_bfast <- function(time_series)
{  # Time series in a ts object without not available values
   ts_trim = ts(coredata(time_series[,1])[!is.na(coredata(time_series[,1]))], freq=365.25/(as.numeric(difftime(index(time_series[2]),index(time_series[1]),units = "days"))), start=decimal_date(ymd(index(time_series[1]))))
   
   # Using BFAST for an iterative break detection in seasonal and trend component of a time series
   bfast(ts_trim, max.iter=1)
}

# Apply BFAST monitor
apply_bfastmonitor <- function(time_series)
{  # Time series in a ts object with part of the original values
   ts_partial = ts(coredata(time_series[,1])[1:270], freq=365.25/(as.numeric(difftime(index(time_series[2]),index(time_series[1]),units = "days"))), start=decimal_date(ymd(index(time_series[1]))))
   
   # Using BFAST for monitoring disturbances in time series in near real-time
   bfastmonitor(ts_partial, start=time(ts_partial)[228], history=time(ts_partial)[1])
}

# Apply TWDTW
apply_twdtw <- function(time_series)
{  # Remove attributes not considered in TWDTW
   keep = c("ndvi", "evi", "red", "nir", "blue", "mir")
   time_series = time_series[, names(time_series) %in% keep]
   
   # Put time series and signatures into the same scale
   time_series = time_series*0.0001

   # Convert time series in a twdtwTimeSeries object
   twdtw_ts = twdtwTimeSeries(time_series)#[,1:AMOUNT_OF_SELECTED_ATTRIBUTES])
   
   # In the region where the time serie was observed, we have soybean, cotton, and maize, whose typical temporal pattern
   #pattern = twdtwTimeSeries(patterns.list)
   
   # Build patterns according to the time series attributes
   attrs = names(time_series)
   new_patterns = list()
   default_patterns = yearly_patterns_mt@timeseries
   for(i in 1:length(default_patterns))
   {  object_zoo = vector("list")
      dates = index(default_patterns[[i]])
      for(ii in 1:length(attrs))
      {  object_zoo[[ii]] = as.vector(coredata(default_patterns[[i]][,c(ii)]))  }
      names(object_zoo) = attrs
      new_patterns[[i]] = as.zoo(as.data.frame(object_zoo), dates)
   }
   names(new_patterns) = names(default_patterns)
   
   # Convert patterns in a twdtwTimeSeries object
   ts_patterns = twdtwTimeSeries(new_patterns)
   
   # Using the the temporal patterns to run the TWDTW analysis
   log_fun = logisticWeight(alpha=-0.1, beta=100) # Logistic time-weight
   twdtwApply(x=twdtw_ts, y=ts_patterns, weight.fun=log_fun, keep=TRUE)
}

